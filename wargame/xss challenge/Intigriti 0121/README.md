## Descriptions

Intigriti 0121 문제는 Dom Based XSS 취약점을 이용해서 XSS를 트리거 하는 문제이다.

---
## Analysis

```html
  <script src="script.js"></script>
```
소스 코드들 확인해 보면 `script.js` 파일을 랜더링 해오는 것을 볼 수 있다.

```js

  window.href = new URL(window.location.href);
  window.r = href.searchParams.get("r");
  //Remove malicious values from href, redirect, referrer, name, ...
  ["document", "window"].forEach(function(interface){
    Object.keys(window[interface]).forEach(function(globalVariable){
        if((typeof window[interface][globalVariable] == "string") && (window[interface][globalVariable].indexOf("javascript") > -1)){
            delete window[interface][globalVariable];
        }
    });
  });
  
  window.onload = function(){
    var links = document.getElementsByTagName("a");
    for(var i = 0; i < links.length; i++){
      links[i].onclick = function(e){
        e.preventDefault();
        safeRedirect(e.target.href);
      }
    }
  }
  if(r != undefined){
    safeRedirect(r);
  }
  function safeRedirect(url){
    if(!url.match(/[<>"' ]/)){
      window.setTimeout(function(){
          if(url.startsWith("https://")){
            window.location = url;
          }
          else{ //local redirect
            window.location = window.origin + "/" + url;
          }
          window.setTimeout(function(){
            document.getElementById("error").style.display = "block";
          }, 1000);
      }, 5000);
      document.getElementById("popover").innerHTML = `
        <p>You're being redirected to ${url} in 5 seconds...</p>
        <p id="error" style="display:none">
          If you're not being redirected, click <a href=${url}>here</a>
        </p>.`;
    }
    else{
      alert("Invalid URL.");
    }
  }
```
`script.js`의 코드는 위와 같다. 일단 위에서 부터 차근 차근 분석을 진행하기로 했다.

```js
  window.href = new URL(window.location.href);
  window.r = href.searchParams.get("r");
  //Remove malicious values from href, redirect, referrer, name, ...
  ["document", "window"].forEach(function(interface){
    Object.keys(window[interface]).forEach(function(globalVariable){
        if((typeof window[interface][globalVariable] == "string") && (window[interface][globalVariable].indexOf("javascript") > -1)){
            delete window[interface][globalVariable];
        }
    });
  });
```
제일 먼저 URL 객체를 생성하고, `searchParams` 메서드를 이용해서 `r`라는 파리미터의 값을 가져오는 것을 볼 수 있다. 그 후에 `forEach` 문을 이용해서 전역 변수(r)가 문자열이고, `"javascript"`라는 문자열이 있으면 해당 객체 전체를 삭제하는 것을 볼 수 있다. `javascript` 스키마 사용을 방지하고 있는 거 같은데 그냥 `JavAscriPt`와 같이 대문자를 섞어 주면 쉽게 우회할 수 있다.

```js
  window.onload = function(){
    var links = document.getElementsByTagName("a");
    for(var i = 0; i < links.length; i++){
      links[i].onclick = function(e){
        e.preventDefault();
        safeRedirect(e.target.href);
      }
    }
  }
```
다음은 페이지에서 `onload` 메서드가 실행이 되면 a 태그를 가져와 `safeRediect()` 함수로 URL을 넘겨주는 것을 볼 수 있다. 그리고 끝이다. 이 부분은 많이 중요하지 않다.

```js
if(r != undefined){
    safeRedirect(r);
  }
  function safeRedirect(url){
    if(!url.match(/[<>"' ]/)){
      window.setTimeout(function(){
          if(url.startsWith("https://")){
            window.location = url;
          }
          else{ //local redirect
            window.location = window.origin + "/" + url;
          }
          window.setTimeout(function(){
            document.getElementById("error").style.display = "block";
          }, 1000);
      }, 5000);
      document.getElementById("popover").innerHTML = `
        <p>You're being redirected to ${url} in 5 seconds...</p>
        <p id="error" style="display:none">
          If you're not being redirected, click <a href=${url}>here</a>
        </p>.`;
    }
    else{
      alert("Invalid URL.");
    }
  }
```
r의 값이 존재하면 `safeRedirect` 함수를 호출하는 것을 볼 수 있다. `safeRedirect()`의 코드를 보면 일단 입력값에 꺽쇠, 싱글/더들 쿼터 및 공백이 없어야 한다. 만약 조건에 만족한다면 `setTimeout()` 함수를 이용해서 5초가 지낸 후 내부 코드가 실행 되도록 하고 있다.

내부 코드를 보면 입력값의 시작이 `https://`이면 그냥 입력 받은 url로 리다이렉트 시켜주는 것을 볼 수 있고, 만약 입력값의 시작이 `https://`가 아니라면 `window.origin + "/" + url;`으로 라디아렉트 시키는 것을 볼 수 있다. 아마 이 부분에서 Dom Based XSS 취약점이 발생하는 거 같고, `javascript` 스키마를 이용해서 트리거 해야 하는 거 같다.

```
JaVascript:alrt(1)
```
하지만 r의 값으로 위와 같이 보내줘도 결국에는 window.origin과 더하기 때문에 결과적으로 사용하는 값은 `https://challenge-0121.intigriti.io//JaVascript:alrt(1)`과 될 것 인데. 이는 뒤에 JS 스키마가 실행되지 않는다.

결국에는 `window.origin`의 값을 조작해야 한다. 

- 시나리오

1. window.origin을 삭제한다.<br>
2. a 태그의 id 값으로 origin을 넣어준다.<br>
3. 그럼 window.origin의 값이 따로 정의 되어 있지 않다. 따라서 window.origin을 참조하게 되면 a 태그를 참조하게 되어 있다.

```html
<!DOCTYPE html>
<html>
    <head>
        <title>Test</title>
        <script>
            const Del = function (){
                delete window['origin'];
                console.log('[+] Delete origin');
            }
        </script>
    </head>
    <body>
        <input type='button' onclick=Del() value='Delete origin'>
        <a href='https://pocas.kr' id='origin'></a>
    </body>
</html>
```
일단 확인을 하기 위해 위와 같이 Test 코드를 작성해주었다.

![](https://github.com/wjddnjs33/Poc/blob/main/wargame/xss%20challenge/Intigriti%200121/images/Before%20delete.png?raw=true)

서버를 열고 접속 한 후에, window.origin을 입력하면 현재 오리진 주소가 나오는 것을 볼 수 있다.

![](https://github.com/wjddnjs33/Poc/blob/main/wargame/xss%20challenge/Intigriti%200121/images/After%20delete.png?raw=true)

그 후에 `Delete origin` 버튼을 눌러서 오리진을 삭제 한 후에, window.origin을 입력해 보니 a 태그를 참조하는 것을 볼 수 있다. 그럼 이제 window.origin을 어떻게 삭제할 지 생각해보아야 한다.

---
## Exploit

---
## Poc (Sollution)

--
## Reference

---
